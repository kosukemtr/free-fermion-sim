import numpy as np
from scipy.linalg import expm


def majorana_hamiltonian(x: np.ndarray) -> np.ndarray:
    """Return the antisymmetric Majorana Hamiltonian.

    Parameters
    ----------
    x : np.ndarray
        Any square real matrix.

    Returns
    -------
    np.ndarray
        Antisymmetric matrix ``(x - x.T)/2``.
    """
    return 0.5 * (x - x.T)


def orthogonal_from_hamiltonian(A: np.ndarray) -> np.ndarray:
    """Return the orthogonal transformation generated by ``A``.

    Parameters
    ----------
    A : np.ndarray
        Real antisymmetric matrix representing a Majorana Hamiltonian.

    Returns
    -------
    np.ndarray
        Orthogonal matrix ``O = expm(A)``.
    """
    return expm(A)


def covariance_from_occupation(occ, N: int) -> np.ndarray:
    """Return covariance matrix for a Fock state.

    Parameters
    ----------
    occ : Iterable[int]
        List of occupied modes ``0 <= i < N``.
    N : int
        Number of modes.

    Returns
    -------
    np.ndarray
        ``2N x 2N`` antisymmetric covariance matrix.
    """
    Gamma = np.zeros((2 * N, 2 * N))
    for j in range(N):
        val = 1 if j in occ else -1
        block = np.array([[0, val], [-val, 0]])
        Gamma[2 * j : 2 * j + 2, 2 * j : 2 * j + 2] = block
    return Gamma


def evolve_covariance(Gamma: np.ndarray, O: np.ndarray) -> np.ndarray:
    """Evolve a covariance matrix under orthogonal ``O``."""
    return O @ Gamma @ O.T


def orbital_to_majorana_rotation(U: np.ndarray) -> np.ndarray:
    """Convert a unitary orbital rotation to a Majorana rotation.

    Parameters
    ----------
    U : np.ndarray
        ``N x N`` unitary matrix acting on annihilation operators.

    Returns
    -------
    np.ndarray
        ``2N x 2N`` real orthogonal matrix acting on Majorana operators.
    """
    Re = U.real
    Im = U.imag
    top = np.hstack((Re, -Im))
    bottom = np.hstack((Im, Re))
    return np.vstack((top, bottom))


def _occupation_from_covariance(Gamma: np.ndarray) -> np.ndarray:
    """Return occupation numbers inferred from a Fock-state covariance."""
    N = Gamma.shape[0] // 2
    occ = []
    for j in range(N):
        block = Gamma[2*j:2*j+2, 2*j:2*j+2]
        if np.allclose(block, np.array([[0, 1], [-1, 0]])):
            occ.append(j)
    return occ


def get_bitstring_probs_from_covariance(Gamma: np.ndarray) -> np.ndarray:
    """Return probabilities for all basis states for a Fock-state covariance."""
    N = Gamma.shape[0] // 2
    occ = _occupation_from_covariance(Gamma)
    idx = sum(1 << (N - 1 - i) for i in occ)
    probs = np.zeros(2**N)
    probs[idx] = 1.0
    return probs


def sample_fermion_state(Gamma: np.ndarray) -> str:
    """Sample a computational basis state from a Fock-state covariance."""
    N = Gamma.shape[0] // 2
    occ = _occupation_from_covariance(Gamma)
    bitstring = ['0'] * N
    for i in occ:
        bitstring[i] = '1'
    return ''.join(bitstring)


def sample_evolved_state(occ, U: np.ndarray) -> str:
    """Sample from a state obtained by evolving a Fock state under ``U``.

    Parameters
    ----------
    occ : Iterable[int]
        Occupied modes in the initial Fock state.
    U : np.ndarray
        Unitary orbital rotation matrix.

    Returns
    -------
    str
        Bitstring sample of length ``N``.
    """
    N = U.shape[0]
    Gamma = covariance_from_occupation(occ, N)
    O = orbital_to_majorana_rotation(U)
    evolved = evolve_covariance(Gamma, O)
    return sample_fermion_state(evolved)
